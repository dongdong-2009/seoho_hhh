<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>MODUS-1000: Project : MODUS-1000_MMI</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- 다음에 의해 생성됨 :  Doxygen 1.5.9 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li class="current"><a href="index.html"><span>메인&nbsp;페이지</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Project : MODUS-1000_MMI</h1>
<p>
<h2><a class="anchor" name="intro">
소개</a></h2>
<ul>
<li>소개 : datfile_t는 텍스트 파일을 이용하여 문자열, 정수, 실수, Boolean 값을 구분자로 구별하면서 읽거나 쓸 수 있도로 처리한다.</li><li>설명 : main() 함수에는 datfile_t를 이용하여 dat 파일 내용을 출력하는 예제를 포함</li></ul>
<p>
----------------------------------------------------------------------------------------------------- <h2><a class="anchor" name="HISTORY">
히스토리</a></h2>
090223<ul>
<li>폴더(modbusw)의 소스를 EPU-100보드에 포팅함</li><li>소스분석은 아직 못했고 동작에 이상은 없어보임</li><li>베이스소스의 출처는 구글에서 검색함 폴더안에 PDF정보가 있음</li></ul>
<p>
090317<ul>
<li>PCB입고 : 4대 조립</li></ul>
<p>
090320 기본동작 테스트:<ul>
<li>기존 MODUS프로토콜 소스를 포팅하여 LED점등 테스트</li></ul>
<p>
<ul>
<li>드라이버 충돌이 발생하여 AVR-JTAG를 인식하지 못하였음<ul>
<li>프로그램을 새로 설치 하여 해결</li></ul>
</li></ul>
<p>
090324<ul>
<li>UART동작 시험<ul>
<li>PC와 통신하여 정상동작 하는지 확인함</li><li>modbus프로토콜 소스가 정상동작하는지 확인함<ul>
<li>통신채널 4채널을 차례로 점검<ul>
<li>통신쪽은 이상없음</li></ul>
</li></ul>
</li><li>LCD장착<ul>
<li>개발용으로 만든보드는 뒷면으로 모든 부품을 조립하여 LCD핀이 거꾸로 되어버림</li><li>핀을 납땜으로 다시연결</li><li>딥핑후 패드가 떨어져나가는 현상이 있음<ul>
<li>주의해야함</li></ul>
</li></ul>
</li></ul>
</li></ul>
<p>
090331<ul>
<li>MMI전용 SMPS연결 시험<ul>
<li>별문제없이 동작함</li></ul>
</li><li>LCD를 연결신호선들이 끊어짐<ul>
<li>프로그램 개발도 불편하고 보드검증도 쉽지않아 새로 보드를 조립함<ul>
<li>MCU를 다시 붙이고 기본동작 테스트 :이상없음</li></ul>
</li></ul>
</li><li>LCD쪽 타이밍 관련한 부분의 프로그램을 수정, 불필요한 요소를 제거하고 최적화함</li></ul>
<p>
090401<ul>
<li>LCD SHIFT 스크롤 함수 구현<ul>
<li>메뉴화면 프로그램 작성할 때 아랫줄을 스크롤 시킴</li></ul>
</li><li>GPIO테스트 LED와 부저가 연결된 포트의 동작을 확인함</li><li>진행사항<ul>
<li>uart동작 확인 : 이상없음</li><li>modbus 소스포팅 : 동작함 컨트롤 보드와 연동하여 튜닝하여야 함</li><li>LCD 기능 : 이상없음</li><li>GPIO : 동작확인함</li></ul>
</li><li>예정사항<ul>
<li>adc키 점검</li><li>menu 프로그램 -dsp보드 modbus 프로토콜 포팅</li></ul>
</li></ul>
<p>
090402<ul>
<li>ADC키 동작 점검<ul>
<li>ADC초기화하는 과정에서 레지스터 설정에 다서 난해했던 부분이 있었음<ul>
<li>xadc5와 xadc4~0이 나누어져있음</li></ul>
</li></ul>
</li></ul>
<p>
<ul>
<li>현재 10비트 중 하위 2비트를 사용하지 않고 키동작확인함<ul>
<li>default 0xE0, 0x80, 0xC0, 0xAB, 0xC0, 0xD6, 0xDC에서 키가 동작함</li></ul>
</li></ul>
<p>
<ul>
<li>LCD에 한글 띄우기 진행중 : 한글폰트 삽입</li></ul>
<p>
<ul>
<li>UART 프로그램 최적화</li></ul>
<p>
<ul>
<li>MENU 프로그램 진행 ; 소스 포팅중</li></ul>
<p>
090403<ul>
<li>KEY동작을 이용하여 MENU 네비게이션 동작을 구현함<ul>
<li>좌 : 변수/10<ul>
<li>우 : 변수*10</li><li>위 : 변수 +1</li><li>아래 : 변수 -1</li></ul>
</li></ul>
</li></ul>
<p>
연산된 변수는 메뉴핸들링을 위한 핸들이 됨<p>
090414<ul>
<li>데이터 검증은 진행 중<ul>
<li>DSP 수신쪽에 패킷 마지막 데이터가 수신되지 않는 현상</li><li>MMI쪽 485이네이블 신호가 데이터보다 일찍 떨어짐<ul>
<li>인터럽트로 처리후 dsp쪽에서 데이터가 잘 전달받음을 확인함</li></ul>
</li><li>MODUS서버프로그램에서 패킷fault시 오작동하는 현상 소스수정</li><li>MMI쪽 485 TX 이네이블시 RXD단자가 LOW로 떨어지는 현상<ul>
<li>AVR은 이것을 0x00으로 인식함</li></ul>
</li><li>485 이네이블 신호시 수신포트를 disable해줌으로 오작동을 막음</li></ul>
</li></ul>
<p>
<ul>
<li>DSP에서 데이터수신후 응답 송신할 때 10us 딜레이를 줌<ul>
<li>송수신데이터의 간격을 벌림</li></ul>
</li></ul>
<p>
090415(modbus_1000_mmi_090415)<ul>
<li>MODBUS프로토콜 데이터 검증<ul>
<li>실제 사용되는 영역을 확장하고 소스 정리함</li></ul>
</li></ul>
<p>
<ul>
<li>MENU화면 구성<ul>
<li>LCD제어 코드를 좀더 명확하게 수정함</li><li>스크롤 기능이 정상작동 함</li></ul>
</li></ul>
<p>
<ul>
<li>MENU핸들러(변수이름)를 통하여 메뉴화면 이동<ul>
<li>adc키 대신 UART키로 대체</li></ul>
</li></ul>
<p>
<ul>
<li>MENU화면 구성<ul>
<li>1. 운전상태</li><li>2. 수동절체</li><li>3. 이력보기</li><li>4. 파라메타 설정 <br>
;운전상태보기 전압전류값을 통신으로부터 읽어와 LCD에 출력하는 프로그램</li></ul>
</li></ul>
<p>
090415(modbus_1000_mmi_090416)<ul>
<li>프로젝트 백업</li></ul>
<p>
090429(modbus_1000_mmi_090423)<ul>
<li>메모리맵(main_data_array): 메모리정리</li><li>3번 메뉴와 4번 메뉴 위치 바꿈</li></ul>
<p>
090506(modbus_1000_mmi_090506)<ul>
<li>히스토리, 패스워드, 날짜 변경</li><li>이벤트 입력받아 출력</li></ul>
<p>
% release ----------------------------------------------------------------------------------------------------- 090527(modbus_1000_mmi_090527)<ul>
<li>MODBUS관련된 프로그램 수정 DSP<ul>
<li>modbus -&gt; data_array -&gt; 제어변수 -&gt; data_array -&gt;modbus 와 같이 데이터가 전달되어야 하는데 제어변수에서 data_array로 복사가 먼저 이루어져 수신데이터가 지워지는현상<ul>
<li>void modbusStoreData(QUERY* query ) 함수에 read_com_buf();를 삽입함으로 해결</li></ul>
</li><li>Bound_min_max(tmp, -32767, 32767)에서 tmp값이 음수일 때 0값이 되어버림 <div class="fragment"><pre class="fragment"> <span class="comment">/*</span>
<span class="comment">   // Vin_offset</span>
<span class="comment">   tmp = main_data_array[70];</span>
<span class="comment">   Vin_offset = (Bound_min_max(tmp, -32767, 32767));</span>
<span class="comment">   </span>
<span class="comment">   // Vin_gain</span>
<span class="comment">   tmp = main_data_array[71];</span>
<span class="comment">   Vin_gain = (Bound_min_max(tmp, -32767, 32767));</span>
<span class="comment">   </span>
<span class="comment">   // Ain_offset</span>
<span class="comment">   tmp = main_data_array[72];</span>
<span class="comment">   Ain_offset = (Bound_min_max(tmp, -32767, 32767));</span>
<span class="comment">   </span>
<span class="comment">   // Ain_gain</span>
<span class="comment">   tmp = main_data_array[73];</span>
<span class="comment">   Ain_gain = (Bound_min_max(tmp, -32767, 32767));</span>
<span class="comment">   </span>
<span class="comment">   // Vout_offset</span>
<span class="comment">   tmp = main_data_array[74];</span>
<span class="comment">   Vout_offset = (Bound_min_max(tmp, -32767, 32767));</span>
<span class="comment">   </span>
<span class="comment">   // Vout_gain</span>
<span class="comment">   tmp = main_data_array[75];</span>
<span class="comment">   Vout_gain = (Bound_min_max(tmp, -32767, 32767));</span>
<span class="comment">   </span>
<span class="comment">   // Aout_offset</span>
<span class="comment">   tmp = main_data_array[76];</span>
<span class="comment">   Aout_offset = (Bound_min_max(tmp, -32767, 32767));</span>
<span class="comment">   </span>
<span class="comment">   // Aout_gain</span>
<span class="comment">   tmp = main_data_array[77];</span>
<span class="comment">   Aout_gain = (Bound_min_max(tmp, -32767, 32767));</span>
<span class="comment">   </span>
<span class="comment">   // Vbyp_offset</span>
<span class="comment">   tmp = main_data_array[78];</span>
<span class="comment">   Vbyp_offset = (Bound_min_max(tmp, -32767, 32767));</span>
<span class="comment">   </span>
<span class="comment">   // Vbyp_gain</span>
<span class="comment">   tmp = main_data_array[79];</span>
<span class="comment">   Vbyp_gain = (Bound_min_max(tmp, -32767, 32767));</span>
<span class="comment">   </span>
<span class="comment">   // Vbat_offset</span>
<span class="comment">   tmp = main_data_array[80];</span>
<span class="comment">   Vbat_offset = (Bound_min_max(tmp, -32767, 32767));</span>
<span class="comment">   </span>
<span class="comment">   // Vbat_gain</span>
<span class="comment">   tmp = main_data_array[81];</span>
<span class="comment">   Vbat_gain = (Bound_min_max(tmp, -32767, 32767));</span>
<span class="comment">   </span>
<span class="comment">   // Abat_offset</span>
<span class="comment">   tmp = main_data_array[82];</span>
<span class="comment">   Abat_offset = (Bound_min_max(tmp, -32767, 32767));</span>
<span class="comment">   </span>
<span class="comment">   // Abat_gain</span>
<span class="comment">   tmp = main_data_array[83];</span>
<span class="comment">   Abat_gain = (Bound_min_max(tmp, -32767, 32767));</span>
<span class="comment">   </span>
<span class="comment">   // Vdc_offset</span>
<span class="comment">   tmp = main_data_array[84];</span>
<span class="comment">   Vdc_offset = (Bound_min_max(tmp, -32767, 32767));</span>
<span class="comment">   </span>
<span class="comment">   // Vdc_gain</span>
<span class="comment">   tmp = main_data_array[85];</span>
<span class="comment">   Vdc_gain = (Bound_min_max(tmp, -32767, 32767));</span>
<span class="comment">   */</span>
 
   <span class="comment">// Vin_offset</span>
   Vin_offset = main_data_array[70];
   <span class="comment">// Vin_gain</span>
   Vin_gain = main_data_array[71];
   <span class="comment">// Ain_offset</span>
   Ain_offset = main_data_array[72];
   <span class="comment">// Ain_gain</span>
   Ain_gain = main_data_array[73];
   <span class="comment">// Vout_offset</span>
   Vout_offset = main_data_array[74];
   <span class="comment">// Vout_gain</span>
   Vout_gain = main_data_array[75];
   <span class="comment">// Aout_offset</span>
   Aout_offset = main_data_array[76];
   <span class="comment">// Aout_gain</span>
   Aout_gain = main_data_array[77];
   <span class="comment">// Vbyp_offset</span>
   Vbyp_offset = main_data_array[78];
   <span class="comment">// Vbyp_gain</span>
   Vbyp_gain = main_data_array[79];
   <span class="comment">// Vbat_offset</span>
   Vbat_offset = main_data_array[80];
   <span class="comment">// Vbat_gain</span>
   Vbat_gain = main_data_array[81];
   <span class="comment">// Abat_offset</span>
   Abat_offset = main_data_array[82];
   <span class="comment">// Abat_gain</span>
   Abat_gain = main_data_array[83];
   <span class="comment">// Vdc_offset</span>
   Vdc_offset = main_data_array[84];
   <span class="comment">// Vdc_gain</span>
   Vdc_gain = main_data_array[85];
</pre></div></li></ul>
</li></ul>
<p>
MMI<ul>
<li>makeQuery1함수에 버그발견/수정 인수 전달부분이 상수로 고정되어있어 특정번지에 데이터가 잘못전달되는 현상</li></ul>
<p>
<ul>
<li>초기 메뉴에서 10초 뒤에 계통도 화면으로 전환 <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> SYS_1(<span class="keywordtype">void</span>)
 {
  <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> flag=0;
 
  <span class="keywordflow">if</span>(EventFlagC)
  {
   <span class="keywordflow">if</span>(KeyState.KeyValue == ESC)naviMENU = naviMENU / 10;
   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(KeyState.KeyValue == UP)naviMENU = naviMENU - 1;
   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(KeyState.KeyValue == DN)naviMENU = naviMENU + 1;
   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(KeyState.KeyValue == ENTER)naviMENU = naviMENU * 10;
   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(KeyState.KeyValue == (ESC  &amp; UP &amp; DN &amp; ENTER))
   {
    naviMENU = 0xFFFFFFFF;
   }
   
   <span class="keywordflow">if</span>(KeyState.KeyValue != 0xFF)EventTimeC=0;
  }
  <span class="keywordflow">else</span> 
  {
   <span class="keywordflow">if</span>(KeyState.KeyValue != 0xFF)EventFlagC=1;
   <span class="keywordflow">if</span>(naviMENU!=old_naveMENU)EventFlagC=1;
  }
 
  <span class="keywordflow">if</span>((!EventFlagC)&amp;&amp;(flag))RefreshFlag=1;<span class="comment">// event edge</span>
  <span class="keywordflow">else</span> <span class="keywordflow">if</span>((EventFlagC)&amp;&amp;(!flag))RefreshFlag=1;<span class="comment">// event edge</span>
  flag = EventFlagC;
 }
 
 <span class="keywordtype">void</span> PAGE_1(<span class="keywordtype">void</span>)
 {
  <span class="keywordflow">if</span>(EventFlagC)
  {
   GLCD_BufClear(); 
   GLCD_print0508(5, 0,<span class="stringliteral">"--MODUS-1000 UPS--"</span>);
   GLCD_print0508(2, 2, <span class="stringliteral">"1.SYSTEM MEASURE"</span>);
   GLCD_print0508(2, 3, <span class="stringliteral">"2.SYSTEM OPERATION"</span>);
   GLCD_print0508(2, 4, <span class="stringliteral">"3.SYSTEM HISTORY"</span>);
   GLCD_print0508(2, 5, <span class="stringliteral">"4.PARAMETER SETTING"</span>);
   
   GLCD_inversion(12,2,112);
  }
  <span class="keywordflow">else</span>
  {
   GLCD_loaddiagram();
  }
 }
</pre></div></li></ul>
<p>
<ul>
<li>오프셋/게인 변경메뉴(4400..) 시작위치(posInpage)를 1의 자리로 변경함 <div class="fragment"><pre class="fragment">   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(KeyState.KeyValue == RIGHT){ posInpage=5;RefreshFlag=1;}
   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(KeyState.KeyValue == LIFT) { posInpage=0;RefreshFlag=1;}
   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(KeyState.KeyValue == ENTER){ posInpage=5;RefreshFlag=1;}
</pre></div></li></ul>
<p>
090527(modbus_1000_mmi_090610)<ul>
<li>메모리맵과 아래 변수가 일치하지 않았음 Bat_Float_Volt Bat_Equal_volt Bat_Equal_Curr 메모리 맵을 확인하고 수정하여 적용함</li></ul>
<p>
<ul>
<li>오프셋/게인의 값을 조정할 때 통신끊김 화면이 뜨는 현상 <div class="fragment"><pre class="fragment"> <span class="keywordflow">else</span> <span class="keywordflow">if</span>(rc_poll==(BYTE)CMPLT_NO_HOPE)
 {
 start_time=0;<span class="comment">//get_milliseconds();</span>
 mseconds = 0;
 communication_fault = 0;
   communication_fault_cnt = 0;
 modbus_state=0;
 clr_rx() ;
 Poll_flag=0;
 }
</pre></div> 경우의 수를 두어 해결함 3가지 경우의 수가 있음 cmplt : 정상상태 cmplt_hope : 대기상태 (통신이 이루어지지 않으면 타임아웃발생) CMPLT_NO_HOPE : 전송실패(통신이 끊긴상태는 아님)</li></ul>
<p>
<ul>
<li>알람/LED 동작 수정</li><li>히스토리 발생순서 조정 <div class="fragment"><pre class="fragment"> <span class="comment">//===================================================</span>
 <span class="comment">//Vin OUT</span>
   <span class="keywordflow">if</span>((main_data_array[42] &amp; 0x0008) &amp;&amp; (!(event_array[2]&amp;0x0008))){history_update(33);BuzzerFlag=1;AlarmLED=1;}    <span class="comment">//</span>
   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(!(main_data_array[42] &amp; 0x0008) &amp;&amp; ((event_array[2]&amp;0x0008))){AlarmLED=0;GLCD_BuzzerOnOff(0);} 
 
   <span class="keywordflow">if</span>((main_data_array[42] &amp; 0x0080) &amp;&amp; (!(event_array[2]&amp;0x0080))){history_update(29);BuzzerFlag=1;AlarmLED=1;}    <span class="comment">//</span>
   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(!(main_data_array[42] &amp; 0x0080) &amp;&amp; ((event_array[2]&amp;0x0080))){AlarmLED=0;GLCD_BuzzerOnOff(0);} 
 
   <span class="keywordflow">if</span>((main_data_array[42] &amp; 0x0020) &amp;&amp; (!(event_array[2]&amp;0x0020))){history_update(31);}    <span class="comment">//</span>
   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(!(main_data_array[42] &amp; 0x0020) &amp;&amp; ((event_array[2]&amp;0x0020))){} 
 <span class="comment">//====================================================</span>
 
 <span class="comment">//====================================================</span>
 <span class="comment">//Vin IN</span>
   <span class="keywordflow">if</span>((main_data_array[42] &amp; 0x0004) &amp;&amp; (!(event_array[2]&amp;0x0004))){history_update(34);}    <span class="comment">//</span>
   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(!(main_data_array[42] &amp; 0x0004) &amp;&amp; ((event_array[2]&amp;0x0004))){} 
 
   <span class="keywordflow">if</span>((main_data_array[42] &amp; 0x0040) &amp;&amp; (!(event_array[2]&amp;0x0040))){history_update(30);}    <span class="comment">//</span>
   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(!(main_data_array[42] &amp; 0x0040) &amp;&amp; ((event_array[2]&amp;0x0040))){} 
 
   <span class="keywordflow">if</span>((main_data_array[42] &amp; 0x0010) &amp;&amp; (!(event_array[2]&amp;0x0010))){history_update(32);}    <span class="comment">//</span>
   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(!(main_data_array[42] &amp; 0x0010) &amp;&amp; ((event_array[2]&amp;0x0010))){} 
 <span class="comment">//====================================================</span>
</pre></div><ul>
<li>통신 끊김 현상 개선 ; 통신이 끊어졌는데 타임 아웃후 패킷을 2회 재전송해 본 후 통신끊김 이벤트 발생 <div class="fragment"><pre class="fragment">  rc_poll=modbusPacketResponseComplete();
 
  <span class="keywordflow">if</span> ( rc_poll==(BYTE)CMPLT_COMPLETE )
  {
   modbus_state++;
    start_time=0;<span class="comment">//get_milliseconds();</span>
     mseconds = 0;
   communication_fault = 0;
   communication_fault_cnt = 0;
   <span class="keywordflow">break</span>;
  }
 
  <span class="comment">/******************************************************************/</span>
  <span class="comment">/*       IF NO RESPONSE RECEIVED TIME OUT AND SEND NEXT POLL      */</span>
  <span class="comment">/******************************************************************/</span>
  <span class="keywordflow">if</span> ((get_milliseconds()-start_time)&gt;=(UINT32)MB_POLL_TIMEOUT)
  {
   modbus_state=0;
   clr_rx() ;
 
   communication_fault_cnt++;
   <span class="keywordflow">if</span>(2&lt;communication_fault_cnt)
   {
    communication_fault = 1;
   }  
   Poll_flag=0;
  }
          <span class="keywordflow">break</span>;
</pre></div></li></ul>
</li></ul>
<p>
<ul>
<li>090728(modbus_1000_mmi_090724)<ul>
<li>page44XXX SAVE/CANCEL 관련한 동작 수정</li><li>그 외 소소한 버그 수정<ul>
<li>글자 오타 , 변수 맵핑 버그 </li></ul>
</li></ul>
</li></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>생성시간 : Fri Aug 7 11:05:49 2009, 프로젝트명 : MODUS-1000, 생성자 : &nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.9 </small></address>
</body>
</html>
